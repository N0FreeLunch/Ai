# 파도

## 단백질 폴딩

생명체를 구성하는 단백질은 20가지 아미노산의 조합으로 구성된 3차원 조각이다. 이 3차원 조각들이 모여서 세포를 이루고 몸의 조직을 이루고 기관을 이루고 신체를 구성한다.

생명체를 컨트롤하고자 하는 노력에 의해서 인류는 3차원 구조체인 단백질을 어떻게 조합했을 때 인체에 어떤 영향을 끼칠 것인지를 연구했고, 각종 질병을 고치기 위해서 단백질을 어떻게 합성해야 여러 질병에 유효한 영향력을 줄 수 있을지를 탐구하고자 했다.

아미노산으로 단백질을 만들고 이들 단백질을 어떻게 조합을 해야 유효한 결합 강도와 적절한 타이밍에 분리를 할 수 있는 단백질을 만들 수 있을지 알아야 했는데, 아미노산으로 어떻게 조합해야 원하는 모양의 단백질을 만들어 낼 수 있는지 알아내기가 너무 어려웠다.

## 단어의 의미

LLM의 탄생의 이론적 기반을 마련한 제프리 힌턴은 인간의 언어가 단어와 단어의 결합 강도에 의해서 달라진다고 생각했다. 예를 들어 '빨갛다'라는 단어가 있다면 이 단어는 '사과'라는 명사에 붙일 수 있고, '불'이라는 명사에도 붙일 수 있고, 손톱의 매니규어에도 붙일 수 있다. 하지만 저마다 빨갛다는 느낌은 다르다. 불은 강렬하면서도 따뜻하면서도 파괴적인 이미지를 가지고 있고, 사과는 잘 익은 계절의 느낌을 나타내며 맛있다는 연상과 이어지며, 손톱의 매니큐어는 다른 색이 섞이지 않은 빨간 이미지를 떠올리게 한다.

단어와 단어가 어떤 결합을 하냐에 따라 하나의 단어는 다양한 이미지를 떠올리게 한다. 그리고 단어와 단어의 조합이 문장이 되고 글이 될 때 이 빨강이란 단어는 소설의 복선이 되기도 하고, 소설의 특정 챕터의 분위기를 암시하는 단어로 쓰이기도 한다. 주변의 단어들과 문자과 문맥과 연결에 따라서 하나의 단어는 다양한 의미로 해석이 가능한 것이다.

## 알파 폴드

구글 딥마인드가 AI의 연구 주제로 단백질 접합 문제를 대상으로 삼은 것도 단백질이란 것이 단어와 같다는 생각이 있었기 때문이다. 하나의 단백질이 다른 어떤 단백질과 연결되느냐에 따라서 삼차원 모양의 결합 강도와 모양의 양상이 달라진다는 점에서 LLM의 방식과 유사한 방식을 적용할 수 있는 과제였다.

물론 단어와 달리 단백질은 물리적인 특성에 의해서 달라지기 때문에 물리적인 법칙에 의한 제약사항을 고려한 단백질 폴딩을 AI로 예측하였고, 이것이 기존의 인간의 모든 방법을 상회할 정도의 결과를 내었다.

## 한계

생명체에서 보이는 단백질의 복잡성은 단순히 모양만을 예측했다고 해서 되는 것이 아니다. 단백질과 단백질 간의 결합, 이 단백질은 저 단백질과는 상호작용 해야 해, 하지 말아야 해, 강하게 결합 해야 해, 약하게 결합 해야 해, 특정 상황에서 결합이 분리 되어야 해, 다른 단백질과의 상호 작용에서 얼마만큼의 에너지를 전달해야 해, 외부 환경에서 특정 단백질을 보호 해야 해, 연쇄 반응의 트리거가 되고 전달 매개 역할을 해야 해, 환경에 따라 반응의 정도를 달리 해야 해 이런 수 많은 상호 작용이 어떻게 이루어지는지 알아야한다.

알파 폴드가 단백질 모양을 예측하는데 큰 성공을 거두었지만, 사람 생명체를 이루는 모든 단백질의 결합 복잡도에서 극히 작은 일부분을 생성했을 뿐이고, 결합이 쌓이면서 누적되는 작은 오차로 인해서 실제와 다른 예측 또는 예측에 실패하는 경우도 있다.

## 파도

이런 미세한 오차에 의한 예측 실패는 소프트웨어 개발에서도 마찬가지이다. 소프트웨어는 인간의 문제를 소프트웨어를 통해서 해결하기 위해 만들어진다. 비즈니스의 문제, 인간의 불편함 이런 것과 코드를 어떻게 연결지을까?이런 부분의 생각은 인간의 의도와 목적을 완전히 따라잡을 수 없는 영역이므로 AI는 소프트웨어 개발을 하면서 계속해서 오차를 누적할 수 밖에 없고 이 때문에 완전히 다른 시스템을 만들게 된다.

한 번의 파도를 높게 일렁이게 할 수 있다. 하지만 이 패턴이 반복된다. 왜냐하면 오차의 누적이 있기 때문에 파도는 더 높아지지 않는다. 잘함, 잘함, 잘함의 반복이지만, 이 반복으로 뭔가 견고해지지 않는 문제가 발생한다.

## 전통적인 소프트웨어 방법론

전통적인 소프트웨어의 방법론은 로직을 단단하게 쌓아가는 방법을 사용했다. AI보다는 못하지만 소프트웨어의 근본 부터 차근 차근 로직을 쌓아서 재활용성을 확대하고 이를 통해서 좀 더 복잡한 것을 처리하고 좀 더 복잡한 것을 처리하는 방법을 사용했다. 물론 이런 개발 방식을 쓰지 않고 막 만드는 경우도 있었지만, 소프트웨어의 개발 방법론은 복잡성을 처리하기 위해서는 기반이 되는 로직의 단단함을 이용해서 쌓아올리는데 집중했다. 조금 속도는 느리지만 소프트웨어 방법론을 잘 적용해서 만들면 전체 소프트웨어가 견고해지는 장점이 있었다.

AI는 잘한다. 하지만 인간의 통제 없이 일을 시키면 코드가 쌓이면 쌓일수록 견고하지 못하다. 전체를 조망하는 힘, 인간이 겪는 불편함을 개선하는 힘, 여러 논의에 의해 정해지고 논의에 따라 업데이트 되는 사양을 정하는 힘, 회사의 사정과 비즈니스 상황에 따른 트레이드 오프를 고려하는 힘. 기획자의 모호한 말의 의도를 읽어내고 소프트웨어를 만들어내기 위한 논리를 구성하는 일.

이 모든 것에서 소프트웨어는 오차를 누적시킨다. 인간이 완벽하지는 않지만 이 오차를 보정하는 역할을 할 수 있다. 그래서 개발자의 역할은 파도치는 AI의 특성을 단단하고 견고한 방식으로 만드는 것이다.

그래서 중요한 것은 견고한 소프트웨어를 어떻게 만들지 고민을 좀 해 보는 것이 좋다.

## 번역

AI는 번역에 있어서 엄청난 능력을 보여주고 있다. 왜 번역에 있어서 강점을 갖는가? 그것은 번역의 원본이 강약의 가이드라인이 되기 때문이다.

원문은 논리를 전개하는 단단함, 지식으로 압도하는 것이 아닌 적은 지식과 사람들이 공감하고 공통적으로 알만한 직관을 담은 섬세한 문장의 흐름과 논리 전개가 있다. 이것이 베이스가 되어 AI는 어느 정도의 강도로 글을 작성해야하고 어느 정도의 느낌을 담아야 하는지 알 수 있다.

특히 장문의 탄탄한 글일 수록 번역은 더욱 빛을 발한다. AI는 파도와 같이 긴 문장의 논리를 단단히 전개하는 로직을 쌓는데 약하지만 번역에 있어서는 자연스럽고 강력함을 보여주는 이유가 원문이 가이드를 하기 때문이다.

소프트웨어에서 인간의 자연어는 번역의 원문처럼 AI에게 각각의 함수 모듈 객체의 역할이 어느 정도의 의존성이나 경계를 형성하는지 알려 줄 수 있고 이것으로 AI가 작성한 코드의 품질을 향상시키고 통제할 수 있게 된다.
